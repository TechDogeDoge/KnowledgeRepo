# 计算机网络

[TOC]

## HTTP

### HTTP基本知识

HTTP是hypertext transfer protocol的简写，是用于互联网中节点间传输文字、图片、音频、视频、链接等超文本数据的约定和规范

####  常见HTTP状态码

| 状态码 |                          含义                          |          常见的状态码 |
| ------ | :----------------------------------------------------: | --------------------: |
| 1xx    | 提示信息，表示目前是协议处理的中间态，还需要后续的操作 |                       |
| 2xx    |             成功，报文已经收到并被正确处理             |       200， 204， 206 |
| 3xx    |    重定向，资源位置发生变动，需要客户端重新发送请求    |       301， 302， 304 |
| 4xx    |        客户端有误，请求报文有误，服务器无法处理        |       400， 403， 404 |
| 5xx    |      服务器错误，服务器在处理请求时内部发生了错误      | 500， 501， 502， 503 |

- 1xx

    `1xx`类状态码属于提示信息，表示目前是协议处理的中间态，还需要后续的操作，实际用到的比较少；

- 2xx

    `2xx`类表示服务器成功处理请求：

    ​	200 OK ：最常见的成功码；

    ​	204 no content：成功，但是没有返回任何数据，页面也不需要加载新的资源或者跳转；

    ​	206 partial content：成功，但客户端表明自己只需要目标URL上的部分资源的时候返回的状态码；

- 3xx

    `3xx`类表示客户端请求的资源发生了变更，需要跳转到新的URL，即重定向；

    ​	301： 永久重定向，代表原本请求的资源不存在；

    ​	302：临时重定向，代表原本请求的资源还存在，但是需要跳转到新的页面；

    ​	304：重定向至客户端缓存文件。当客户端已经缓存请求的文件时，服务器会根据缓存文件修改日期和请求文件修改日期的前后，判断返回的状态码；如果缓存文件修改日期在前，需要向客户端返回最新的文件并返回状态码200；如果请求文件修改日期在前，只需要客户端重定向到缓存的文件，服务器返回状态码304；

- 4xx

    `4xx`类表示客户端请求有误；

    ​	400：笼统表示客户端请求有误；

    ​	401：请求的资源需要先对客户端进行认证

    ​	403：表示服务器禁止访问请求资源；

    ​	404：表示请求资源在服务器上不存在或者找不到；

- 5xx

    `5xx`类表示客户端请求正确，但服务器处理时出现错误；

    ​	500：笼统表示服务器处理有误；

    ​	501：表示客户端的请求暂不支持；

    ​	502：表示服务器访问下一个服务器时，没有收到正确响应

    ​	503：表示服务器很忙，暂时无法响应请求 

#### HTTP Headers常见字段

host：访问服务器的域名，如www.google.com

content-length：返回数据的长度

connection：通常使用keep-alive来建立长连接，一般来说连接会重用（请求完成以后不会关闭连接）；

content-type：服务器发送数据的格式，如text/html

charset：服务器数据的字符集，如utf-8

accept：客户端请求中声明可接收的数据格式，如`*/*`，text/html

content-encoding：服务器数据的压缩格式，如gzip

accept-encoding：客户端可以接收的压缩数据，如gzip，deflate

### GET与POST

GET和POST是两种不同的HTTP请求方法。GET是从服务器获取数据；POST是向服务器发送数据。GET安全且幂等，POST不安全且不幂等。

> 安全：请求方法不会变更服务器上的资源；
>
> 幂等：多次执行相同的请求方法，结果都是相同的；

### HTTP特性

#### 优点

1. 简单：采用`header + body`，`header`中采用`key-value`的形式
2. 灵活和易于扩展：`HTTP`工作在应用层，下层可以随意变化，且协议没有定义死各类请求方法、状态码、URL。
3. 应用广泛和跨平台：从手机到电脑，全部采用`HTTP`

#### 缺点

1. 无状态：虽然采用无状态，可以不用记录HTTP的状态信息，减轻服务器的负担，但是也同样有缺点。例如登陆->添加购物车->下单->结算->支付，这一系列操作都需要知道用户的身份信息，但是由于无状态，服务器不知道这些操作全部和同一个用户相关，于是每次操作都需要询问一次身份信息，造成整个过程较慢。对于这个缺点，采用`cookie`可以解决，通过在请求和响应报文中添加`cookie`信息。
2. 明文传输：虽然采用明文传输，方便阅读，但是容易造成信息泄露。
3. 不安全：不对通信方身份进行验证，不保证报文完整性

### HTTP与HTTPS

> SSL: Secure Socket Layer
>
> TLS: Transport Layer Security

1. HTTPS在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使得报文可以加密传输
2. HTTPS在HTTP的三次握手建立连接的基础上，新增了SSL/TLS的握手过程
3. HTTP使用端口80，HTTPS使用端口443
4. HTTPS中需要向CA(证书权威机构)申请数字证书，用来验证身份和数据传输加密



信息加密：采用混合加密实现信息的机密性

完整性校验机制：使用摘要算法实现完整性，为数据生成独一无二的"指纹"，如果篡改，则"指纹"校验一定不通过

身份证书：公钥放入到数字证书中，解决了冒充的风险



> 加密方式
>
> 对称加密：加密和解密采用同一个密钥
>
> 非对称加密：使用一对非对称的密钥，一把私有密钥，一把公有密钥。公有密钥可以随意发布，任何人都可以获得。发送密文的一方，使用公开密钥进行加密；接收密文的一方，使用私有密钥进行解密。

HTTPS加密

HTTPS借助CA（证书权威机构）采用混合加密对报文进行加密。

在建立连接时，采用非对称加密来交换密钥；建立连接后，采用对称加密来传输数据。

1. 服务器将公钥key1发送给CA

2. CA使用自己的私钥加密服务器公钥得到数字证书并返回给服务器
3. 客户端向服务器发送请求时，服务器将数字证书发送给客户端
4. 客户端收到数字证书后，使用CA的公钥验证数字证书的真实性，并获取了服务器的公钥
5. 后面客户端和服务器之间交换数据分别采用服务器的公私钥

![image-20220109161102050](C:\Users\jiaoy\AppData\Roaming\Typora\typora-user-images\image-20220109161102050.png)

### HTTP演进

HTTP1.1相比HTTP1.0：

- 使用长连接代替短连接，改善了性能开销。短连接一般在建立连接后完成一次读写就会关闭连接，而长连接则不会立马关闭连接，而是依然保持连接，直到下一次数据交互
- 支持管道的网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少响应时间

HTTP2相比HTTP1.1：

- HTTP演进为HTTPS，增强安全性
- 压缩header
- 将原本文本形式的报文，转换为二进制格式的报文，为计算机减少了文本转换为二进制的步骤
- 新增数据流的数据发送方式
- 支持并发请求或者回应，且不需要按照顺序一一对应
- 新增服务器推送

HTTP3相比HTTP2：

- 将底层的TCP替换为UDP。由于HTTP2中多个请求复用一个TCP连接，而下层TCP协议是不知道有多少个HTTPP请求的，所以一旦发生丢包，就会出发TCP重传，于是这个TCP连接中的所有HTTP请求都必须等待这个丢了的包被重传回来。
- 新增QUICL协议，实现类似TCP的可靠传输

<img src="C:\Users\jiaoy\AppData\Roaming\Typora\typora-user-images\image-20220109174708269.png" alt="image-20220109174708269" style="zoom: 80%;" />

<img src="C:\Users\jiaoy\AppData\Roaming\Typora\typora-user-images\image-20220109174939319.png" alt="image-20220109174939319" style="zoom:80%;" />

## TCP

TCP（Transmission Control Protocol）是工作在传输层的可靠数据传输的服务，可以确保数据接收是**无损坏、无间隔、非冗余、按序的**。

### 三次握手

1. 客户端随机初始化一个客户端序号`client_isn`，并将报文中`SYN`标志位置为1，用来表示本报文为`SYN`报文，将报文发送给服务器
2. 服务器收到`SYN`报文后，随机初始化一个服务器序号`server_isn`，并将`client_isn + 1`填入到报文的确认应答号位置，然后将`SYN`，`ACK`标志位置为1，将报文发送给客户端
3. 客户端确认报文中的`SYN`，`ACK`和确认应答号符合预期。客户端将报文`ACK`标志位置为1，并将`server_isn + 1`填入到报文的确认应答号位置，最后将报文发送给服务器。服务器收到报文符合预期，则连接建立。

### 四次挥手

1. 客户端将报文中`FIN`标志位置为1，用来表示本报文为`FIN`报文，将报文发送给服务器
2. 服务器收到报文后，向客户端发送`ACK`报文，表示确认收到`FIN`报文
3. 服务器处理完数据后，向客户端发送`FIN`报文
4. 客户端收到服务器的`FIN`报文后，回复一个`ACK`报文
5. 服务器收到`ACK`报文，服务器完成连接关闭；而客户端在发出`ACK`报文后，经过`2MSL`客户端完成连接关闭

> 为何客户端需要等待2MSL（Maximum Segment Lifetime）
>
> 确保原连接的报文不会影响后面新连接。因为服务器在发送一个报文后，关闭连接，如果客户端不等待的话，报文经过延迟，有可能在客户端重新建立新的连接后接收到这个过期的报文，产生，数据错乱等问题。而如果经过这个2MSL的等待时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失。
>
> 确保连接正常关闭。如果等待时间太短，而客户端最后回复的`ACK`报文在网络中丢失，就会影响后面新连接的建立。如果等待2MSL，服务器就会在没有收到`ACK`报文时，重发`FIN`报文关闭连接并等待新的`ACK`报文。

### TCP重传机制

#### 超时重传

一端发送数据后，设定定时器超过指定时间没有收到对方的应答报文，就会重发该数据，也就是超时重传

#### 快速重传

当发送数据端，连续收到三个相同的`ACK`，就会在定时器超市前，触发重传。为何会出现三个相同`ACK`的情况？

<img src="C:\Users\jiaoy\AppData\Roaming\Typora\typora-user-images\image-20220110231542361.png" alt="image-20220110231542361" style="zoom: 80%;" />

> 由于接收方一直没有收到`SEQ2`所以才会一直回复`ACK2`

但是超时重传的问题就是需要重传的报文不容易确定，为了解决这个问题，就有了`SACK`方法

#### SACK

`SACK`就是在TCP头部添加一个叫`SACK(Selective ACK)`的东西，它可以将接收方已经收到的数据地图发送给发送方。这样发送方就可以知道接收方收到哪些数据，丢失哪些数据，于是发送方就可以只重传丢失的数据。

![image-20220111202529391](C:\Users\jiaoy\AppData\Roaming\Typora\typora-user-images\image-20220111202529391.png)

#### D-SACK

使用`SACK`来告诉发送方有哪些数据被重复接收了

### 窗口

窗口的存在是为了让发送方可以无需等待响应`ACK`，就可以继续发送数据

窗口的大小就是未收到`ACK`前，可以发送的最大数据，通常由接收方的处理能力决定

### 流量控制

通过窗口的辅助，可以实现流量控制。

### TCP连接队列

在TCP三次握手建立连接的时候，内核会维护两个队列：

1. 半连接队列，也称SYN队列
2. 全连接队列，也称ACCEPT队列

服务端收到客户端发起的SYN请求后，内核会把该连接存储到半连接队列中，并向客户端响应ACK+SYN。当服务器收到客户端的ACK后，内核会把此连接从半连接队列中移除，然后创建新的完全的连接，并将其添加到全连接队列中。

## IP

IP工作在网络层上，负责实现节点与节点之间的通信，和数据链路层（MAC）之间的区别在于数据链路层负责两个直连节点之间的通信。

### IP地址

IPv4地址由32个比特位组成，IPv6地址由48个比特位组成

最初按照IP地址高位比特位的取值可以分为A、B、C、D、E类地址，后面由于分类地址的局限性，采用无分类地址，这种方式将IP地址的比特位分为两部分：网络号和主机号，用来表示一个设备的唯一地址。

分类地址：10.100.122.2；

无分类地址：10.100.122.2/24；

> 无分类地址中`/24`代表前24个比特位是网络，剩下的比特位是主机号

#### 子网掩码

子网掩码可以用来计算一个主机所属的网络号，以及划分子网。通过子网掩码和IP地址做`AND`运算就可以得到网络号。寻址时，如果发现两个节点的网络号相同，说明两个节点在同一子网，可以直接将数据进行发送。

<img src="C:\Users\jiaoy\AppData\Roaming\Typora\typora-user-images\image-20220111231025122.png" alt="image-20220111231025122" style="zoom:50%;" />

子网掩码还进一步将主机号分为两个部分：子网号+主机号

对于**分类**地址：分类已经表明了网络号长度，而子网掩码和IP地址`AND`运算得到的是网络号+主机号，由此可以确定网络号，子网号，主机号分别占据多少比特位；

对于**无分类**地址：网络号长度直接写明，而子网掩码和IP地址`AND`运算可以得到网络号+主机号，由此可以确定网络号，子网号，主机号分别占据多少比特位；

#### 公有IP地址和私有IP地址

对于A、B、C类地址实际上会分公有IP地址和私有IP地址

<img src="C:\Users\jiaoy\AppData\Roaming\Typora\typora-user-images\image-20220116130242962.png" alt="image-20220116130242962" style="zoom:67%;" />

私有IP地址一般是由学校、办公室等机构的IT人员自己管理分配的。就好比一个人家的门牌号是1栋101号，而另一个人家的门牌号也是1栋101号，但两个人分属于不同的小区，对应于IP就是两个人拥有相同的私有IP地址(1栋101号)，但是公有地址(小区名)不同。**公有IP地址是全球唯一的，私有IP地址不是全球唯一的。**

### 路由控制

IP地址就相当于一个节点在全局中的坐标标识。于是在进行路由寻址的时候，也是按照IP地址进行寻址。

首先在主机和路由器中会存储一个路由表，路由表采用`key-value`的形式存储**目标IP地址**和**下一跳的IP地址**。当数据传输到路由器时，根据数据的目标地址和路由表中的目标地址进行匹配，由此确定数据下一跳的地址。

### 分片与重组

数据链路中可以传输的最大单元，叫做`MTU`。IP数据包的大小不能超过`MTU`，于是有较大的数据包要进行传输的时候，发送方需要将数据包首先进行分片，最后再由接受方将分片重组

### DNS

`DNS`是Domain Name System的缩写。通常我们在上网的时候，并不是使用IP地址进行访问，而是使用域名进行访问，比如`www.google.com`。而`DNS`就是用来实现将域名自动转换为IP地址的。

DNS服务器采用树的结构进行部署，根节点为根DNS服务器，下面就是顶级域DNS服务器，然后下面还有更多的DNS服务器。

浏览器要访问某一指定域名时，会经历以下过程

1. 查询浏览器缓存中有没有域名对应的IP地址，如果没有，继续查询操作系统的缓存和本地域名解析文件hosts
2. 如果前面都没有查到，首先向本地DNS服务器发送一个DNS请求来查询域名对应的IP地址
3. 本地DNS服务器收到请求后，如果缓存中存有域名和域名对应的I牌地址，则会直接返回，否则会向根DNS服务器询问
4. 根DNS服务器收到请求后，给本地DNS服务器指明需要询问的下一层DNS服务器
5. 本地DNS服务器继续向下一层DNS服务器发送请求，直到最后收到返回的IP地址

<img src="C:\Users\jiaoy\AppData\Roaming\Typora\typora-user-images\image-20220116152226531.png" alt="image-20220116152226531" style="zoom:67%;" />

## 其他

### 从输入网址到显示网页 

从在浏览器中输入网址到最终浏览器显示网页，中间发生了哪些过程？设涉及哪些协议？

1. 浏览器对输入的URL进行解析
2. 利用URL解析的结果生成HTTP请求
3. 利用DNS获取URL对应的IP地址
4. 在应用层生成HTTP报文
5. HTTP报文传递到传输层，  生成TCP报文
6. TCP报文传递到网络层，生成IP报文
7. IP报文传递到数据链路层，在IP报文前面加上目的MAC地址和源MAC地址，形成帧
8. 将帧在节点间不断传递，直到服务器
9. 服务器处理请求，并返回响应，按照和上面相反的步骤最后回到浏览器

